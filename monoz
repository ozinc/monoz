#!/usr/bin/env node

var request = require('request');
var async = require('async');
var config = require('./config');
var util = require('util');
var argv = require('optimist').argv;
var datadog = require('./lib/datadog');
var probeModules = require('./lib/probes');
var _ = require('lodash');

// Help?

if (argv.help || argv.h) {
  usage();
  process.exit(0);
}

// Configuration

var sourceName;
if (argv.s || argv.source) {
  sourceName = argv.s || argv.source;
}

var datadogApiKey = config.datadogApiKey;
var interval = (config.interval || 60) * 1000;
var probes = config.probes || [];

if (!datadogApiKey) {
  console.log('WARN: You did not provide a DataDog API key so not logging to DataDog.');
}

if (datadogApiKey && !sourceName) {
  console.log('ERR: To be able to send to DataDog you HAVE TO provide a source name, see help.');
  process.exit(-1);
}

if (probes.length === 0) {
  console.log('ERR: You need to provide a non-zero list of probes in config.json.');
  process.exit(-1);
}

// Resolve templates
var templates = [];
_.forEach(config.templates, function (value, key) { templates[key] = value; } );

// Helper functions

function usage() {
  console.log();
  console.log('  Usage: ./monoz [options]');
  console.log()
  console.log('  Options:');
  console.log();
  console.log('    -h, --help     Shows this help.');
  console.log('    -s, --source   A name identifying this process as a source in DataDog.');
  console.log();
}

// Runs all of the probes.

function run() {
  console.log('> running all probes');

  var fns = [];

  // Resolve probes
  for (var i = 0; i < probes.length; i++) {
    var probe = probes[i];

    // Apply template - start with that as type can come from there
    if (probe.template) {
      if (!templates[probe.template]) {
        console.log('  ERR: template "' + probe.template + '" does not exist, skipping probe.');
        continue;
      }
      else {
        // Applying probe over template so values from template don't override the probe settings
        probe = _.extend({}, templates[probe.template], probe);
      }
    }

    // Verify we have an implementation of the type defined for the probe
    if (!_.has(probeModules, probe.type)) {
      console.log('  ERR: no probe with type=' + probe.type + ' exists, skipping.');
      console.log(JSON.stringify(probe));
      continue;
    }

    // Adds DataDog and the source name to the probe options.
    if (datadogApiKey) {
      probe = _.extend(probe, { datadogApiKey: datadogApiKey, sourceName: sourceName });
    }

    fns.push(probeModules[probe.type](probe));
  }

  async.series(fns, function (err) {
    if (err) {
      console.log('ERROR: test run failed!');
      console.log(err);
    }

    // Deliver the metrics to DataDog (if some DataDog API key was provided in config.json).
    if (datadogApiKey) {
      console.log('> Sending stats to DataDog: '+ datadog.getQueueSize());
      datadog.send(datadogApiKey, function (err) {
        if (err) {
          console.log('> failed to send stats to DataDog!');
          console.log(err);
        } else {
          console.log('> successfully delivered stats to DataDog.');
          console.log();
        }
      });
    } else {
      console.log();
    }
  });
}

// Run immediately!

run();

// If a DataDog API key is provided we want to run continuously.
if (datadogApiKey) {
  setInterval(run, interval);
}
